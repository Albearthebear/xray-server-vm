#!/bin/bash

# --- Configuration ---
# Secret name in Google Secret Manager for the UUID
UUID_SECRET_NAME="xray-vless-uuid"
# Google Cloud Project ID (Replace!)
PROJECT_ID="green-hell-450120"
# Your container image on GHCR (Replace!)
XRAY_IMAGE="ghcr.io/albearthebear/xray-server-vm:latest"
# Your domain name (Replace!)
DOMAIN_NAME="prostoy-fitnes.xyz"

# Host paths
CONFIG_DIR="/mnt/stateful_partition/etc/xray" # Use stateful partition for config
CONFIG_FILE="${CONFIG_DIR}/config.json"
HOST_LE_CERTS_DIR="/mnt/stateful_partition/etc/letsencrypt/live/${DOMAIN_NAME}" # Path to certs generated by certbot
HOST_LOG_DIR="${CONFIG_DIR}/logs"

# Internal container paths
CONTAINER_CERT_DIR="/app/certs" # Where certs will be mounted inside container
CONTAINER_CONFIG_FILE="/app/config.json"
CONTAINER_LOG_DIR="/var/log/xray" # Match this with config.json log paths

echo "--- Xray Startup Script Begin ---"

# Create directories on stateful partition
echo "Creating directories..."
mkdir -p "${CONFIG_DIR}"
mkdir -p "${HOST_LOG_DIR}"

# Check if certificates exist locally
if [ ! -f "${HOST_LE_CERTS_DIR}/fullchain.pem" ] || [ ! -f "${HOST_LE_CERTS_DIR}/privkey.pem" ]; then
    echo "ERROR: Let's Encrypt certificates not found at ${HOST_LE_CERTS_DIR}/"
    echo "Please ensure you have run certbot successfully and the domain name (${DOMAIN_NAME}) is correct."
    exit 1
fi
echo "Local certificates found."

# Metadata key for the UUID
UUID_METADATA_KEY="xray-uuid"

# Fetch UUID from instance metadata
echo "Fetching VLESS UUID from metadata key '${UUID_METADATA_KEY}'..."
# Use curl to query the metadata server
# Adding retries in case metadata server isn't ready immediately
RETRY_COUNT=0
MAX_RETRIES=5
SLEEP_TIME=2
VLESS_UUID=""
while [ -z "$VLESS_UUID" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
  VLESS_UUID=$(curl -s "http://metadata.google.internal/computeMetadata/v1/instance/attributes/${UUID_METADATA_KEY}" -H "Metadata-Flavor: Google")
  if [ -z "$VLESS_UUID" ]; then
    echo "Metadata key not found or empty, retrying (${RETRY_COUNT}/${MAX_RETRIES})..."
    sleep $SLEEP_TIME
    RETRY_COUNT=$((RETRY_COUNT+1))
  fi
done

if [ -z "$VLESS_UUID" ]; then
 echo "ERROR: Failed to fetch UUID from metadata key '${UUID_METADATA_KEY}' after ${MAX_RETRIES} retries."
 exit 1
fi
echo "UUID fetched successfully from metadata."

# Generate config.json dynamically
echo "Generating ${CONFIG_FILE}..."
cat << EOF > "${CONFIG_FILE}"
{
  "log": {
    "access": "${CONTAINER_LOG_DIR}/access.log",
    "error": "${CONTAINER_LOG_DIR}/error.log",
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "port": 8000,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "${VLESS_UUID}",
            "level": 0
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "tls",
        "tlsSettings": {
          "minVersion": "1.3",
          "cipherSuites": "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
          "certificates": [
            {
              "certificateFile": "${CONTAINER_CERT_DIR}/fullchain.pem",
              "keyFile": "${CONTAINER_CERT_DIR}/privkey.pem"
            }
          ]
        },
        "sockopt": {
          "tcpFastOpen": true,
          "tcpNoDelay": true
        }
      }
    },
    {
      "port": 80,
      "protocol": "dokodemo-door",
      "settings": {
        "address": "127.0.0.1",
        "port": 1,
        "network": "tcp"
      },
      "tag": "health",
      "listen": "0.0.0.0"
    }
  ],
  "outbounds": [
    {
      "protocol": "freedom",
      "settings": {},
      "tag": "direct"
    },
    {
      "protocol": "blackhole",
      "settings": {},
      "tag": "block"
    }
  ],
  "routing": {
    "rules": [
      {
        "type": "field",
        "inboundTag": ["health"],
        "outboundTag": "block"
      }
    ],
    "domainStrategy": "AsIs"
  }
}
EOF
echo "${CONFIG_FILE} generated."

# Set permissions (optional, but good practice)
# Permissions on LE certs are usually okay, but config file might need read access for container
chmod 644 "${CONFIG_FILE}"
# Ensure logs are writable by container user (if xray runs non-root, might need group permissions or chown)

# Pull the latest image
echo "Pulling Xray image: ${XRAY_IMAGE}..."
docker pull "${XRAY_IMAGE}"
if [ $? -ne 0 ]; then
 echo "ERROR: Failed to pull image ${XRAY_IMAGE}"
 exit 1
fi
echo "Image pulled."

# Stop and remove existing container if it exists
echo "Checking for existing container..."
docker stop xray-server || true
docker rm xray-server || true

# Run the container (single line version) with health check port
echo "Starting Xray container..."
docker run -d --name xray-server --restart always -p 443:8000 -p 8080:80 -v "${HOST_LE_CERTS_DIR}:${CONTAINER_CERT_DIR}:ro" -v "${CONFIG_FILE}:${CONTAINER_CONFIG_FILE}:ro" -v "${HOST_LOG_DIR}:${CONTAINER_LOG_DIR}" "${XRAY_IMAGE}"

if [ $? -ne 0 ]; then
 echo "ERROR: Failed to start container ${XRAY_IMAGE}"
 exit 1
fi

echo "--- Xray container started successfully! ---"
echo "--- Xray Startup Script End ---"